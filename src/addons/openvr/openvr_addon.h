#ifndef TRUSS_OPENVR_HEADER
#define TRUSS_OPENVR_HEADER

#include "../../truss.h"
#include <openvr.h>

#define TRUSS_OPENVR_DX11 0
#define TRUSS_OPENVR_GL   1

class OpenVRAddon : public truss::Addon {
public:
    OpenVRAddon();
    const std::string& getName();
    const std::string& getHeader();
    const std::string& getVersion();
    void init(truss::Interpreter* owner);
    void shutdown();
    void update(double dt);

    int initVR(int graphicsApiMode);
    int shutdownVR();

    vr::IVRSystem* ivrsystem_;

    ~OpenVRAddon(); // needed so it can be deleted cleanly

    std::string name_;
    std::string version_;
    std::string header_;
    std::string lastError_;
    truss::Interpreter* owner_;
};

// Addon api: mainly for creating and getting the individual openvr systems
TRUSS_C_API int truss_openvr_init(OpenVRAddon* addon, int graphicsApiMode);
TRUSS_C_API int truss_openvr_shutdown(OpenVRAddon* addon);
TRUSS_C_API const char* truss_openvr_get_last_error(OpenVRAddon* addon);
TRUSS_C_API void* truss_openvr_get_system(OpenVRAddon* addon);
TRUSS_C_API void* truss_openvr_get_chaperone(OpenVRAddon* addon);
TRUSS_C_API void* truss_openvr_get_chaperonesetup(OpenVRAddon* addon);
TRUSS_C_API void* truss_openvr_get_compositor(OpenVRAddon* addon);
TRUSS_C_API void* truss_openvr_get_overlay(OpenVRAddon* addon);
TRUSS_C_API void* truss_openvr_get_rendermodels(OpenVRAddon* addon);
TRUSS_C_API void* truss_openvr_get_extendeddisplay(OpenVRAddon* addon);
TRUSS_C_API void* truss_openvr_get_settings(OpenVRAddon* addon);
TRUSS_C_API void* truss_openvr_get_applications(OpenVRAddon* addon);
TRUSS_C_API void* truss_openvr_get_camera(OpenVRAddon* addon);
TRUSS_C_API void* truss_openvr_get_input(OpenVRAddon* addon);


// Direct C-api to openvr:
//
TRUSS_C_API void tr_ovw_GetRecommendedRenderTargetSize(vr::IVRSystem* self, uint32_t * pnWidth, uint32_t * pnHeight);
TRUSS_C_API vr::HmdMatrix44_t tr_ovw_GetProjectionMatrix(vr::IVRSystem* self, vr::EVREye eEye, float fNearZ, float fFarZ);
TRUSS_C_API void tr_ovw_GetProjectionRaw(vr::IVRSystem* self, vr::EVREye eEye, float * pfLeft, float * pfRight, float * pfTop, float * pfBottom);
TRUSS_C_API bool tr_ovw_ComputeDistortion(vr::IVRSystem* self, vr::EVREye eEye, float fU, float fV, vr::DistortionCoordinates_t * pDistortionCoordinates);
TRUSS_C_API vr::HmdMatrix34_t tr_ovw_GetEyeToHeadTransform(vr::IVRSystem* self, vr::EVREye eEye);
TRUSS_C_API bool tr_ovw_GetTimeSinceLastVsync(vr::IVRSystem* self, float * pfSecondsSinceLastVsync, uint64_t * pulFrameCounter);
TRUSS_C_API int32_t tr_ovw_GetD3D9AdapterIndex(vr::IVRSystem* self);
TRUSS_C_API void tr_ovw_GetDXGIOutputInfo(vr::IVRSystem* self, int32_t * pnAdapterIndex);
TRUSS_C_API void tr_ovw_GetOutputDevice(vr::IVRSystem* self, uint64_t * pnDevice, vr::ETextureType textureType, VkInstance_T * pInstance);
TRUSS_C_API bool tr_ovw_IsDisplayOnDesktop(vr::IVRSystem* self);
TRUSS_C_API bool tr_ovw_SetDisplayVisibility(vr::IVRSystem* self, bool bIsVisibleOnDesktop);
TRUSS_C_API void tr_ovw_GetDeviceToAbsoluteTrackingPose(vr::IVRSystem* self, vr::ETrackingUniverseOrigin eOrigin, float fPredictedSecondsToPhotonsFromNow, vr::TrackedDevicePose_t * pTrackedDevicePoseArray, uint32_t unTrackedDevicePoseArrayCount);
TRUSS_C_API void tr_ovw_ResetSeatedZeroPose(vr::IVRSystem* self);
TRUSS_C_API vr::HmdMatrix34_t tr_ovw_GetSeatedZeroPoseToStandingAbsoluteTrackingPose(vr::IVRSystem* self);
TRUSS_C_API vr::HmdMatrix34_t tr_ovw_GetRawZeroPoseToStandingAbsoluteTrackingPose(vr::IVRSystem* self);
TRUSS_C_API uint32_t tr_ovw_GetSortedTrackedDeviceIndicesOfClass(vr::IVRSystem* self, vr::ETrackedDeviceClass eTrackedDeviceClass, vr::TrackedDeviceIndex_t * punTrackedDeviceIndexArray, uint32_t unTrackedDeviceIndexArrayCount, vr::TrackedDeviceIndex_t unRelativeToTrackedDeviceIndex);
TRUSS_C_API vr::EDeviceActivityLevel tr_ovw_GetTrackedDeviceActivityLevel(vr::IVRSystem* self, vr::TrackedDeviceIndex_t unDeviceId);
TRUSS_C_API void tr_ovw_ApplyTransform(vr::IVRSystem* self, vr::TrackedDevicePose_t * pOutputPose, vr::TrackedDevicePose_t * pTrackedDevicePose, vr::HmdMatrix34_t * pTransform);
TRUSS_C_API vr::TrackedDeviceIndex_t tr_ovw_GetTrackedDeviceIndexForControllerRole(vr::IVRSystem* self, vr::ETrackedControllerRole unDeviceType);
TRUSS_C_API vr::ETrackedControllerRole tr_ovw_GetControllerRoleForTrackedDeviceIndex(vr::IVRSystem* self, vr::TrackedDeviceIndex_t unDeviceIndex);
TRUSS_C_API vr::ETrackedDeviceClass tr_ovw_GetTrackedDeviceClass(vr::IVRSystem* self, vr::TrackedDeviceIndex_t unDeviceIndex);
TRUSS_C_API bool tr_ovw_IsTrackedDeviceConnected(vr::IVRSystem* self, vr::TrackedDeviceIndex_t unDeviceIndex);
TRUSS_C_API bool tr_ovw_GetBoolTrackedDeviceProperty(vr::IVRSystem* self, vr::TrackedDeviceIndex_t unDeviceIndex, vr::ETrackedDeviceProperty prop, vr::ETrackedPropertyError * pError);
TRUSS_C_API float tr_ovw_GetFloatTrackedDeviceProperty(vr::IVRSystem* self, vr::TrackedDeviceIndex_t unDeviceIndex, vr::ETrackedDeviceProperty prop, vr::ETrackedPropertyError * pError);
TRUSS_C_API int32_t tr_ovw_GetInt32TrackedDeviceProperty(vr::IVRSystem* self, vr::TrackedDeviceIndex_t unDeviceIndex, vr::ETrackedDeviceProperty prop, vr::ETrackedPropertyError * pError);
TRUSS_C_API uint64_t tr_ovw_GetUint64TrackedDeviceProperty(vr::IVRSystem* self, vr::TrackedDeviceIndex_t unDeviceIndex, vr::ETrackedDeviceProperty prop, vr::ETrackedPropertyError * pError);
TRUSS_C_API vr::HmdMatrix34_t tr_ovw_GetMatrix34TrackedDeviceProperty(vr::IVRSystem* self, vr::TrackedDeviceIndex_t unDeviceIndex, vr::ETrackedDeviceProperty prop, vr::ETrackedPropertyError * pError);
TRUSS_C_API uint32_t tr_ovw_GetArrayTrackedDeviceProperty(vr::IVRSystem* self, vr::TrackedDeviceIndex_t unDeviceIndex, vr::ETrackedDeviceProperty prop, vr::PropertyTypeTag_t propType, void * pBuffer, uint32_t unBufferSize, vr::ETrackedPropertyError * pError);
TRUSS_C_API uint32_t tr_ovw_GetStringTrackedDeviceProperty(vr::IVRSystem* self, vr::TrackedDeviceIndex_t unDeviceIndex, vr::ETrackedDeviceProperty prop, char * pchValue, uint32_t unBufferSize, vr::ETrackedPropertyError * pError);
TRUSS_C_API const char * tr_ovw_GetPropErrorNameFromEnum(vr::IVRSystem* self, vr::ETrackedPropertyError error);
TRUSS_C_API bool tr_ovw_PollNextEvent(vr::IVRSystem* self, vr::VREvent_t * pEvent, uint32_t uncbVREvent);
TRUSS_C_API bool tr_ovw_PollNextEventWithPose(vr::IVRSystem* self, vr::ETrackingUniverseOrigin eOrigin, vr::VREvent_t * pEvent, uint32_t uncbVREvent, vr::TrackedDevicePose_t * pTrackedDevicePose);
TRUSS_C_API const char * tr_ovw_GetEventTypeNameFromEnum(vr::IVRSystem* self, vr::EVREventType eType);
TRUSS_C_API vr::HiddenAreaMesh_t tr_ovw_GetHiddenAreaMesh(vr::IVRSystem* self, vr::EVREye eEye, vr::EHiddenAreaMeshType type);
TRUSS_C_API bool tr_ovw_GetControllerState(vr::IVRSystem* self, vr::TrackedDeviceIndex_t unControllerDeviceIndex, vr::VRControllerState_t * pControllerState, uint32_t unControllerStateSize);
TRUSS_C_API bool tr_ovw_GetControllerStateWithPose(vr::IVRSystem* self, vr::ETrackingUniverseOrigin eOrigin, vr::TrackedDeviceIndex_t unControllerDeviceIndex, vr::VRControllerState_t * pControllerState, uint32_t unControllerStateSize, vr::TrackedDevicePose_t * pTrackedDevicePose);
TRUSS_C_API void tr_ovw_TriggerHapticPulse(vr::IVRSystem* self, vr::TrackedDeviceIndex_t unControllerDeviceIndex, uint32_t unAxisId, unsigned short usDurationMicroSec);
TRUSS_C_API const char * tr_ovw_GetButtonIdNameFromEnum(vr::IVRSystem* self, vr::EVRButtonId eButtonId);
TRUSS_C_API const char * tr_ovw_GetControllerAxisTypeNameFromEnum(vr::IVRSystem* self, vr::EVRControllerAxisType eAxisType);
TRUSS_C_API bool tr_ovw_IsInputAvailable(vr::IVRSystem* self);
TRUSS_C_API bool tr_ovw_IsSteamVRDrawingControllers(vr::IVRSystem* self);
TRUSS_C_API bool tr_ovw_ShouldApplicationPause(vr::IVRSystem* self);
TRUSS_C_API bool tr_ovw_ShouldApplicationReduceRenderingWork(vr::IVRSystem* self);
TRUSS_C_API uint32_t tr_ovw_DriverDebugRequest(vr::IVRSystem* self, vr::TrackedDeviceIndex_t unDeviceIndex, const char * pchRequest, char * pchResponseBuffer, uint32_t unResponseBufferSize);
TRUSS_C_API vr::EVRFirmwareError tr_ovw_PerformFirmwareUpdate(vr::IVRSystem* self, vr::TrackedDeviceIndex_t unDeviceIndex);
TRUSS_C_API void tr_ovw_AcknowledgeQuit_Exiting(vr::IVRSystem* self);
TRUSS_C_API void tr_ovw_AcknowledgeQuit_UserPrompt(vr::IVRSystem* self);
TRUSS_C_API void tr_ovw_GetWindowBounds(vr::IVRExtendedDisplay* self, int32_t * pnX, int32_t * pnY, uint32_t * pnWidth, uint32_t * pnHeight);
TRUSS_C_API void tr_ovw_GetEyeOutputViewport(vr::IVRExtendedDisplay* self, vr::EVREye eEye, uint32_t * pnX, uint32_t * pnY, uint32_t * pnWidth, uint32_t * pnHeight);
TRUSS_C_API void tr_ovw_GetDXGIOutputInfo(vr::IVRExtendedDisplay* self, int32_t * pnAdapterIndex, int32_t * pnAdapterOutputIndex);
TRUSS_C_API const char * tr_ovw_GetCameraErrorNameFromEnum(vr::IVRTrackedCamera* self, vr::EVRTrackedCameraError eCameraError);
TRUSS_C_API vr::EVRTrackedCameraError tr_ovw_HasCamera(vr::IVRTrackedCamera* self, vr::TrackedDeviceIndex_t nDeviceIndex, bool * pHasCamera);
TRUSS_C_API vr::EVRTrackedCameraError tr_ovw_GetCameraFrameSize(vr::IVRTrackedCamera* self, vr::TrackedDeviceIndex_t nDeviceIndex, vr::EVRTrackedCameraFrameType eFrameType, uint32_t * pnWidth, uint32_t * pnHeight, uint32_t * pnFrameBufferSize);
TRUSS_C_API vr::EVRTrackedCameraError tr_ovw_GetCameraIntrinsics(vr::IVRTrackedCamera* self, vr::TrackedDeviceIndex_t nDeviceIndex, uint32_t nCameraIndex, vr::EVRTrackedCameraFrameType eFrameType, vr::HmdVector2_t * pFocalLength, vr::HmdVector2_t * pCenter);
TRUSS_C_API vr::EVRTrackedCameraError tr_ovw_GetCameraProjection(vr::IVRTrackedCamera* self, vr::TrackedDeviceIndex_t nDeviceIndex, uint32_t nCameraIndex, vr::EVRTrackedCameraFrameType eFrameType, float flZNear, float flZFar, vr::HmdMatrix44_t * pProjection);
TRUSS_C_API vr::EVRTrackedCameraError tr_ovw_AcquireVideoStreamingService(vr::IVRTrackedCamera* self, vr::TrackedDeviceIndex_t nDeviceIndex, vr::TrackedCameraHandle_t * pHandle);
TRUSS_C_API vr::EVRTrackedCameraError tr_ovw_ReleaseVideoStreamingService(vr::IVRTrackedCamera* self, vr::TrackedCameraHandle_t hTrackedCamera);
TRUSS_C_API vr::EVRTrackedCameraError tr_ovw_GetVideoStreamFrameBuffer(vr::IVRTrackedCamera* self, vr::TrackedCameraHandle_t hTrackedCamera, vr::EVRTrackedCameraFrameType eFrameType, void * pFrameBuffer, uint32_t nFrameBufferSize, vr::CameraVideoStreamFrameHeader_t * pFrameHeader, uint32_t nFrameHeaderSize);
TRUSS_C_API vr::EVRTrackedCameraError tr_ovw_GetVideoStreamTextureSize(vr::IVRTrackedCamera* self, vr::TrackedDeviceIndex_t nDeviceIndex, vr::EVRTrackedCameraFrameType eFrameType, vr::VRTextureBounds_t * pTextureBounds, uint32_t * pnWidth, uint32_t * pnHeight);
TRUSS_C_API vr::EVRTrackedCameraError tr_ovw_GetVideoStreamTextureD3D11(vr::IVRTrackedCamera* self, vr::TrackedCameraHandle_t hTrackedCamera, vr::EVRTrackedCameraFrameType eFrameType, void * pD3D11DeviceOrResource, void ** ppD3D11ShaderResourceView, vr::CameraVideoStreamFrameHeader_t * pFrameHeader, uint32_t nFrameHeaderSize);
TRUSS_C_API vr::EVRTrackedCameraError tr_ovw_GetVideoStreamTextureGL(vr::IVRTrackedCamera* self, vr::TrackedCameraHandle_t hTrackedCamera, vr::EVRTrackedCameraFrameType eFrameType, vr::glUInt_t * pglTextureId, vr::CameraVideoStreamFrameHeader_t * pFrameHeader, uint32_t nFrameHeaderSize);
TRUSS_C_API vr::EVRTrackedCameraError tr_ovw_ReleaseVideoStreamTextureGL(vr::IVRTrackedCamera* self, vr::TrackedCameraHandle_t hTrackedCamera, vr::glUInt_t glTextureId);
TRUSS_C_API vr::EVRApplicationError tr_ovw_AddApplicationManifest(vr::IVRApplications* self, const char * pchApplicationManifestFullPath, bool bTemporary);
TRUSS_C_API vr::EVRApplicationError tr_ovw_RemoveApplicationManifest(vr::IVRApplications* self, const char * pchApplicationManifestFullPath);
TRUSS_C_API bool tr_ovw_IsApplicationInstalled(vr::IVRApplications* self, const char * pchAppKey);
TRUSS_C_API uint32_t tr_ovw_GetApplicationCount(vr::IVRApplications* self);
TRUSS_C_API vr::EVRApplicationError tr_ovw_GetApplicationKeyByIndex(vr::IVRApplications* self, uint32_t unApplicationIndex, char * pchAppKeyBuffer, uint32_t unAppKeyBufferLen);
TRUSS_C_API vr::EVRApplicationError tr_ovw_GetApplicationKeyByProcessId(vr::IVRApplications* self, uint32_t unProcessId, char * pchAppKeyBuffer, uint32_t unAppKeyBufferLen);
TRUSS_C_API vr::EVRApplicationError tr_ovw_LaunchApplication(vr::IVRApplications* self, const char * pchAppKey);
TRUSS_C_API vr::EVRApplicationError tr_ovw_LaunchTemplateApplication(vr::IVRApplications* self, const char * pchTemplateAppKey, const char * pchNewAppKey, vr::AppOverrideKeys_t * pKeys, uint32_t unKeys);
TRUSS_C_API vr::EVRApplicationError tr_ovw_LaunchApplicationFromMimeType(vr::IVRApplications* self, const char * pchMimeType, const char * pchArgs);
TRUSS_C_API vr::EVRApplicationError tr_ovw_LaunchDashboardOverlay(vr::IVRApplications* self, const char * pchAppKey);
TRUSS_C_API bool tr_ovw_CancelApplicationLaunch(vr::IVRApplications* self, const char * pchAppKey);
TRUSS_C_API vr::EVRApplicationError tr_ovw_IdentifyApplication(vr::IVRApplications* self, uint32_t unProcessId, const char * pchAppKey);
TRUSS_C_API uint32_t tr_ovw_GetApplicationProcessId(vr::IVRApplications* self, const char * pchAppKey);
TRUSS_C_API const char * tr_ovw_GetApplicationsErrorNameFromEnum(vr::IVRApplications* self, vr::EVRApplicationError error);
TRUSS_C_API uint32_t tr_ovw_GetApplicationPropertyString(vr::IVRApplications* self, const char * pchAppKey, vr::EVRApplicationProperty eProperty, char * pchPropertyValueBuffer, uint32_t unPropertyValueBufferLen, vr::EVRApplicationError * peError);
TRUSS_C_API bool tr_ovw_GetApplicationPropertyBool(vr::IVRApplications* self, const char * pchAppKey, vr::EVRApplicationProperty eProperty, vr::EVRApplicationError * peError);
TRUSS_C_API uint64_t tr_ovw_GetApplicationPropertyUint64(vr::IVRApplications* self, const char * pchAppKey, vr::EVRApplicationProperty eProperty, vr::EVRApplicationError * peError);
TRUSS_C_API vr::EVRApplicationError tr_ovw_SetApplicationAutoLaunch(vr::IVRApplications* self, const char * pchAppKey, bool bAutoLaunch);
TRUSS_C_API bool tr_ovw_GetApplicationAutoLaunch(vr::IVRApplications* self, const char * pchAppKey);
TRUSS_C_API vr::EVRApplicationError tr_ovw_SetDefaultApplicationForMimeType(vr::IVRApplications* self, const char * pchAppKey, const char * pchMimeType);
TRUSS_C_API bool tr_ovw_GetDefaultApplicationForMimeType(vr::IVRApplications* self, const char * pchMimeType, char * pchAppKeyBuffer, uint32_t unAppKeyBufferLen);
TRUSS_C_API bool tr_ovw_GetApplicationSupportedMimeTypes(vr::IVRApplications* self, const char * pchAppKey, char * pchMimeTypesBuffer, uint32_t unMimeTypesBuffer);
TRUSS_C_API uint32_t tr_ovw_GetApplicationsThatSupportMimeType(vr::IVRApplications* self, const char * pchMimeType, char * pchAppKeysThatSupportBuffer, uint32_t unAppKeysThatSupportBuffer);
TRUSS_C_API uint32_t tr_ovw_GetApplicationLaunchArguments(vr::IVRApplications* self, uint32_t unHandle, char * pchArgs, uint32_t unArgs);
TRUSS_C_API vr::EVRApplicationError tr_ovw_GetStartingApplication(vr::IVRApplications* self, char * pchAppKeyBuffer, uint32_t unAppKeyBufferLen);
TRUSS_C_API vr::EVRApplicationTransitionState tr_ovw_GetTransitionState(vr::IVRApplications* self);
TRUSS_C_API vr::EVRApplicationError tr_ovw_PerformApplicationPrelaunchCheck(vr::IVRApplications* self, const char * pchAppKey);
TRUSS_C_API const char * tr_ovw_GetApplicationsTransitionStateNameFromEnum(vr::IVRApplications* self, vr::EVRApplicationTransitionState state);
TRUSS_C_API bool tr_ovw_IsQuitUserPromptRequested(vr::IVRApplications* self);
TRUSS_C_API vr::EVRApplicationError tr_ovw_LaunchInternalProcess(vr::IVRApplications* self, const char * pchBinaryPath, const char * pchArguments, const char * pchWorkingDirectory);
TRUSS_C_API uint32_t tr_ovw_GetCurrentSceneProcessId(vr::IVRApplications* self);
TRUSS_C_API vr::ChaperoneCalibrationState tr_ovw_GetCalibrationState(vr::IVRChaperone* self);
TRUSS_C_API bool tr_ovw_GetPlayAreaSize(vr::IVRChaperone* self, float * pSizeX, float * pSizeZ);
TRUSS_C_API bool tr_ovw_GetPlayAreaRect(vr::IVRChaperone* self, vr::HmdQuad_t * rect);
TRUSS_C_API void tr_ovw_ReloadInfo(vr::IVRChaperone* self);
TRUSS_C_API void tr_ovw_SetSceneColor(vr::IVRChaperone* self, vr::HmdColor_t color);
TRUSS_C_API void tr_ovw_GetBoundsColor(vr::IVRChaperone* self, vr::HmdColor_t * pOutputColorArray, int nNumOutputColors, float flCollisionBoundsFadeDistance, vr::HmdColor_t * pOutputCameraColor);
TRUSS_C_API bool tr_ovw_AreBoundsVisible(vr::IVRChaperone* self);
TRUSS_C_API void tr_ovw_ForceBoundsVisible(vr::IVRChaperone* self, bool bForce);
TRUSS_C_API bool tr_ovw_CommitWorkingCopy(vr::IVRChaperoneSetup* self, vr::EChaperoneConfigFile configFile);
TRUSS_C_API void tr_ovw_RevertWorkingCopy(vr::IVRChaperoneSetup* self);
TRUSS_C_API bool tr_ovw_GetWorkingPlayAreaSize(vr::IVRChaperoneSetup* self, float * pSizeX, float * pSizeZ);
TRUSS_C_API bool tr_ovw_GetWorkingPlayAreaRect(vr::IVRChaperoneSetup* self, vr::HmdQuad_t * rect);
TRUSS_C_API bool tr_ovw_GetWorkingCollisionBoundsInfo(vr::IVRChaperoneSetup* self, vr::HmdQuad_t * pQuadsBuffer, uint32_t * punQuadsCount);
TRUSS_C_API bool tr_ovw_GetLiveCollisionBoundsInfo(vr::IVRChaperoneSetup* self, vr::HmdQuad_t * pQuadsBuffer, uint32_t * punQuadsCount);
TRUSS_C_API bool tr_ovw_GetWorkingSeatedZeroPoseToRawTrackingPose(vr::IVRChaperoneSetup* self, vr::HmdMatrix34_t * pmatSeatedZeroPoseToRawTrackingPose);
TRUSS_C_API bool tr_ovw_GetWorkingStandingZeroPoseToRawTrackingPose(vr::IVRChaperoneSetup* self, vr::HmdMatrix34_t * pmatStandingZeroPoseToRawTrackingPose);
TRUSS_C_API void tr_ovw_SetWorkingPlayAreaSize(vr::IVRChaperoneSetup* self, float sizeX, float sizeZ);
TRUSS_C_API void tr_ovw_SetWorkingCollisionBoundsInfo(vr::IVRChaperoneSetup* self, vr::HmdQuad_t * pQuadsBuffer, uint32_t unQuadsCount);
TRUSS_C_API void tr_ovw_SetWorkingPerimeter(vr::IVRChaperoneSetup* self, vr::HmdVector2_t * pPointBuffer, uint32_t unPointCount);
TRUSS_C_API void tr_ovw_SetWorkingSeatedZeroPoseToRawTrackingPose(vr::IVRChaperoneSetup* self, vr::HmdMatrix34_t * pMatSeatedZeroPoseToRawTrackingPose);
TRUSS_C_API void tr_ovw_SetWorkingStandingZeroPoseToRawTrackingPose(vr::IVRChaperoneSetup* self, vr::HmdMatrix34_t * pMatStandingZeroPoseToRawTrackingPose);
TRUSS_C_API void tr_ovw_ReloadFromDisk(vr::IVRChaperoneSetup* self, vr::EChaperoneConfigFile configFile);
TRUSS_C_API bool tr_ovw_GetLiveSeatedZeroPoseToRawTrackingPose(vr::IVRChaperoneSetup* self, vr::HmdMatrix34_t * pmatSeatedZeroPoseToRawTrackingPose);
TRUSS_C_API bool tr_ovw_ExportLiveToBuffer(vr::IVRChaperoneSetup* self, char * pBuffer, uint32_t * pnBufferLength);
TRUSS_C_API bool tr_ovw_ImportFromBufferToWorking(vr::IVRChaperoneSetup* self, const char * pBuffer, uint32_t nImportFlags);
TRUSS_C_API void tr_ovw_ShowWorkingSetPreview(vr::IVRChaperoneSetup* self);
TRUSS_C_API void tr_ovw_HideWorkingSetPreview(vr::IVRChaperoneSetup* self);
TRUSS_C_API void tr_ovw_SetTrackingSpace(vr::IVRCompositor* self, vr::ETrackingUniverseOrigin eOrigin);
TRUSS_C_API vr::ETrackingUniverseOrigin tr_ovw_GetTrackingSpace(vr::IVRCompositor* self);
TRUSS_C_API vr::EVRCompositorError tr_ovw_WaitGetPoses(vr::IVRCompositor* self, vr::TrackedDevicePose_t * pRenderPoseArray, uint32_t unRenderPoseArrayCount, vr::TrackedDevicePose_t * pGamePoseArray, uint32_t unGamePoseArrayCount);
TRUSS_C_API vr::EVRCompositorError tr_ovw_GetLastPoses(vr::IVRCompositor* self, vr::TrackedDevicePose_t * pRenderPoseArray, uint32_t unRenderPoseArrayCount, vr::TrackedDevicePose_t * pGamePoseArray, uint32_t unGamePoseArrayCount);
TRUSS_C_API vr::EVRCompositorError tr_ovw_GetLastPoseForTrackedDeviceIndex(vr::IVRCompositor* self, vr::TrackedDeviceIndex_t unDeviceIndex, vr::TrackedDevicePose_t * pOutputPose, vr::TrackedDevicePose_t * pOutputGamePose);
TRUSS_C_API vr::EVRCompositorError tr_ovw_Submit(vr::IVRCompositor* self, vr::EVREye eEye, vr::Texture_t * pTexture, vr::VRTextureBounds_t * pBounds, vr::EVRSubmitFlags nSubmitFlags);
TRUSS_C_API void tr_ovw_ClearLastSubmittedFrame(vr::IVRCompositor* self);
TRUSS_C_API void tr_ovw_PostPresentHandoff(vr::IVRCompositor* self);
TRUSS_C_API bool tr_ovw_GetFrameTiming(vr::IVRCompositor* self, vr::Compositor_FrameTiming * pTiming, uint32_t unFramesAgo);
TRUSS_C_API uint32_t tr_ovw_GetFrameTimings(vr::IVRCompositor* self, vr::Compositor_FrameTiming * pTiming, uint32_t nFrames);
TRUSS_C_API float tr_ovw_GetFrameTimeRemaining(vr::IVRCompositor* self);
TRUSS_C_API void tr_ovw_GetCumulativeStats(vr::IVRCompositor* self, vr::Compositor_CumulativeStats * pStats, uint32_t nStatsSizeInBytes);
TRUSS_C_API void tr_ovw_FadeToColor(vr::IVRCompositor* self, float fSeconds, float fRed, float fGreen, float fBlue, float fAlpha, bool bBackground);
TRUSS_C_API vr::HmdColor_t tr_ovw_GetCurrentFadeColor(vr::IVRCompositor* self, bool bBackground);
TRUSS_C_API void tr_ovw_FadeGrid(vr::IVRCompositor* self, float fSeconds, bool bFadeIn);
TRUSS_C_API float tr_ovw_GetCurrentGridAlpha(vr::IVRCompositor* self);
TRUSS_C_API vr::EVRCompositorError tr_ovw_SetSkyboxOverride(vr::IVRCompositor* self, vr::Texture_t * pTextures, uint32_t unTextureCount);
TRUSS_C_API void tr_ovw_ClearSkyboxOverride(vr::IVRCompositor* self);
TRUSS_C_API void tr_ovw_CompositorBringToFront(vr::IVRCompositor* self);
TRUSS_C_API void tr_ovw_CompositorGoToBack(vr::IVRCompositor* self);
TRUSS_C_API void tr_ovw_CompositorQuit(vr::IVRCompositor* self);
TRUSS_C_API bool tr_ovw_IsFullscreen(vr::IVRCompositor* self);
TRUSS_C_API uint32_t tr_ovw_GetCurrentSceneFocusProcess(vr::IVRCompositor* self);
TRUSS_C_API uint32_t tr_ovw_GetLastFrameRenderer(vr::IVRCompositor* self);
TRUSS_C_API bool tr_ovw_CanRenderScene(vr::IVRCompositor* self);
TRUSS_C_API void tr_ovw_ShowMirrorWindow(vr::IVRCompositor* self);
TRUSS_C_API void tr_ovw_HideMirrorWindow(vr::IVRCompositor* self);
TRUSS_C_API bool tr_ovw_IsMirrorWindowVisible(vr::IVRCompositor* self);
TRUSS_C_API void tr_ovw_CompositorDumpImages(vr::IVRCompositor* self);
TRUSS_C_API bool tr_ovw_ShouldAppRenderWithLowResources(vr::IVRCompositor* self);
TRUSS_C_API void tr_ovw_ForceInterleavedReprojectionOn(vr::IVRCompositor* self, bool bOverride);
TRUSS_C_API void tr_ovw_ForceReconnectProcess(vr::IVRCompositor* self);
TRUSS_C_API void tr_ovw_SuspendRendering(vr::IVRCompositor* self, bool bSuspend);
TRUSS_C_API vr::EVRCompositorError tr_ovw_GetMirrorTextureD3D11(vr::IVRCompositor* self, vr::EVREye eEye, void * pD3D11DeviceOrResource, void ** ppD3D11ShaderResourceView);
TRUSS_C_API void tr_ovw_ReleaseMirrorTextureD3D11(vr::IVRCompositor* self, void * pD3D11ShaderResourceView);
TRUSS_C_API vr::EVRCompositorError tr_ovw_GetMirrorTextureGL(vr::IVRCompositor* self, vr::EVREye eEye, vr::glUInt_t * pglTextureId, vr::glSharedTextureHandle_t * pglSharedTextureHandle);
TRUSS_C_API bool tr_ovw_ReleaseSharedGLTexture(vr::IVRCompositor* self, vr::glUInt_t glTextureId, vr::glSharedTextureHandle_t glSharedTextureHandle);
TRUSS_C_API void tr_ovw_LockGLSharedTextureForAccess(vr::IVRCompositor* self, vr::glSharedTextureHandle_t glSharedTextureHandle);
TRUSS_C_API void tr_ovw_UnlockGLSharedTextureForAccess(vr::IVRCompositor* self, vr::glSharedTextureHandle_t glSharedTextureHandle);
TRUSS_C_API uint32_t tr_ovw_GetVulkanInstanceExtensionsRequired(vr::IVRCompositor* self, char * pchValue, uint32_t unBufferSize);
TRUSS_C_API uint32_t tr_ovw_GetVulkanDeviceExtensionsRequired(vr::IVRCompositor* self, VkPhysicalDevice_T * pPhysicalDevice, char * pchValue, uint32_t unBufferSize);
TRUSS_C_API void tr_ovw_SetExplicitTimingMode(vr::IVRCompositor* self, vr::EVRCompositorTimingMode eTimingMode);
TRUSS_C_API vr::EVRCompositorError tr_ovw_SubmitExplicitTimingData(vr::IVRCompositor* self);
TRUSS_C_API bool tr_ovw_IsMotionSmoothingEnabled(vr::IVRCompositor* self);
TRUSS_C_API vr::EVROverlayError tr_ovw_FindOverlay(vr::IVROverlay* self, const char * pchOverlayKey, vr::VROverlayHandle_t * pOverlayHandle);
TRUSS_C_API vr::EVROverlayError tr_ovw_CreateOverlay(vr::IVROverlay* self, const char * pchOverlayKey, const char * pchOverlayName, vr::VROverlayHandle_t * pOverlayHandle);
TRUSS_C_API vr::EVROverlayError tr_ovw_DestroyOverlay(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle);
TRUSS_C_API vr::EVROverlayError tr_ovw_SetHighQualityOverlay(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle);
TRUSS_C_API vr::VROverlayHandle_t tr_ovw_GetHighQualityOverlay(vr::IVROverlay* self);
TRUSS_C_API uint32_t tr_ovw_GetOverlayKey(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle, char * pchValue, uint32_t unBufferSize, vr::EVROverlayError * pError);
TRUSS_C_API uint32_t tr_ovw_GetOverlayName(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle, char * pchValue, uint32_t unBufferSize, vr::EVROverlayError * pError);
TRUSS_C_API vr::EVROverlayError tr_ovw_SetOverlayName(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle, const char * pchName);
TRUSS_C_API vr::EVROverlayError tr_ovw_GetOverlayImageData(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle, void * pvBuffer, uint32_t unBufferSize, uint32_t * punWidth, uint32_t * punHeight);
TRUSS_C_API const char * tr_ovw_GetOverlayErrorNameFromEnum(vr::IVROverlay* self, vr::EVROverlayError error);
TRUSS_C_API vr::EVROverlayError tr_ovw_SetOverlayRenderingPid(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle, uint32_t unPID);
TRUSS_C_API uint32_t tr_ovw_GetOverlayRenderingPid(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle);
TRUSS_C_API vr::EVROverlayError tr_ovw_SetOverlayFlag(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle, vr::VROverlayFlags eOverlayFlag, bool bEnabled);
TRUSS_C_API vr::EVROverlayError tr_ovw_GetOverlayFlag(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle, vr::VROverlayFlags eOverlayFlag, bool * pbEnabled);
TRUSS_C_API vr::EVROverlayError tr_ovw_SetOverlayColor(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle, float fRed, float fGreen, float fBlue);
TRUSS_C_API vr::EVROverlayError tr_ovw_GetOverlayColor(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle, float * pfRed, float * pfGreen, float * pfBlue);
TRUSS_C_API vr::EVROverlayError tr_ovw_SetOverlayAlpha(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle, float fAlpha);
TRUSS_C_API vr::EVROverlayError tr_ovw_GetOverlayAlpha(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle, float * pfAlpha);
TRUSS_C_API vr::EVROverlayError tr_ovw_SetOverlayTexelAspect(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle, float fTexelAspect);
TRUSS_C_API vr::EVROverlayError tr_ovw_GetOverlayTexelAspect(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle, float * pfTexelAspect);
TRUSS_C_API vr::EVROverlayError tr_ovw_SetOverlaySortOrder(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle, uint32_t unSortOrder);
TRUSS_C_API vr::EVROverlayError tr_ovw_GetOverlaySortOrder(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle, uint32_t * punSortOrder);
TRUSS_C_API vr::EVROverlayError tr_ovw_SetOverlayWidthInMeters(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle, float fWidthInMeters);
TRUSS_C_API vr::EVROverlayError tr_ovw_GetOverlayWidthInMeters(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle, float * pfWidthInMeters);
TRUSS_C_API vr::EVROverlayError tr_ovw_SetOverlayAutoCurveDistanceRangeInMeters(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle, float fMinDistanceInMeters, float fMaxDistanceInMeters);
TRUSS_C_API vr::EVROverlayError tr_ovw_GetOverlayAutoCurveDistanceRangeInMeters(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle, float * pfMinDistanceInMeters, float * pfMaxDistanceInMeters);
TRUSS_C_API vr::EVROverlayError tr_ovw_SetOverlayTextureColorSpace(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle, vr::EColorSpace eTextureColorSpace);
TRUSS_C_API vr::EVROverlayError tr_ovw_GetOverlayTextureColorSpace(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle, vr::EColorSpace * peTextureColorSpace);
TRUSS_C_API vr::EVROverlayError tr_ovw_SetOverlayTextureBounds(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle, vr::VRTextureBounds_t * pOverlayTextureBounds);
TRUSS_C_API vr::EVROverlayError tr_ovw_GetOverlayTextureBounds(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle, vr::VRTextureBounds_t * pOverlayTextureBounds);
TRUSS_C_API uint32_t tr_ovw_GetOverlayRenderModel(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle, char * pchValue, uint32_t unBufferSize, vr::HmdColor_t * pColor, vr::EVROverlayError * pError);
TRUSS_C_API vr::EVROverlayError tr_ovw_SetOverlayRenderModel(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle, const char * pchRenderModel, vr::HmdColor_t * pColor);
TRUSS_C_API vr::EVROverlayError tr_ovw_GetOverlayTransformType(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle, vr::VROverlayTransformType * peTransformType);
TRUSS_C_API vr::EVROverlayError tr_ovw_SetOverlayTransformAbsolute(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle, vr::ETrackingUniverseOrigin eTrackingOrigin, vr::HmdMatrix34_t * pmatTrackingOriginToOverlayTransform);
TRUSS_C_API vr::EVROverlayError tr_ovw_GetOverlayTransformAbsolute(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle, vr::ETrackingUniverseOrigin * peTrackingOrigin, vr::HmdMatrix34_t * pmatTrackingOriginToOverlayTransform);
TRUSS_C_API vr::EVROverlayError tr_ovw_SetOverlayTransformTrackedDeviceRelative(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle, vr::TrackedDeviceIndex_t unTrackedDevice, vr::HmdMatrix34_t * pmatTrackedDeviceToOverlayTransform);
TRUSS_C_API vr::EVROverlayError tr_ovw_GetOverlayTransformTrackedDeviceRelative(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle, vr::TrackedDeviceIndex_t * punTrackedDevice, vr::HmdMatrix34_t * pmatTrackedDeviceToOverlayTransform);
TRUSS_C_API vr::EVROverlayError tr_ovw_SetOverlayTransformTrackedDeviceComponent(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle, vr::TrackedDeviceIndex_t unDeviceIndex, const char * pchComponentName);
TRUSS_C_API vr::EVROverlayError tr_ovw_GetOverlayTransformTrackedDeviceComponent(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle, vr::TrackedDeviceIndex_t * punDeviceIndex, char * pchComponentName, uint32_t unComponentNameSize);
TRUSS_C_API vr::EVROverlayError tr_ovw_GetOverlayTransformOverlayRelative(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle, vr::VROverlayHandle_t * ulOverlayHandleParent, vr::HmdMatrix34_t * pmatParentOverlayToOverlayTransform);
TRUSS_C_API vr::EVROverlayError tr_ovw_SetOverlayTransformOverlayRelative(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle, vr::VROverlayHandle_t ulOverlayHandleParent, vr::HmdMatrix34_t * pmatParentOverlayToOverlayTransform);
TRUSS_C_API vr::EVROverlayError tr_ovw_ShowOverlay(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle);
TRUSS_C_API vr::EVROverlayError tr_ovw_HideOverlay(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle);
TRUSS_C_API bool tr_ovw_IsOverlayVisible(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle);
TRUSS_C_API vr::EVROverlayError tr_ovw_GetTransformForOverlayCoordinates(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle, vr::ETrackingUniverseOrigin eTrackingOrigin, vr::HmdVector2_t coordinatesInOverlay, vr::HmdMatrix34_t * pmatTransform);
TRUSS_C_API bool tr_ovw_PollNextOverlayEvent(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle, vr::VREvent_t * pEvent, uint32_t uncbVREvent);
TRUSS_C_API vr::EVROverlayError tr_ovw_GetOverlayInputMethod(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle, vr::VROverlayInputMethod * peInputMethod);
TRUSS_C_API vr::EVROverlayError tr_ovw_SetOverlayInputMethod(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle, vr::VROverlayInputMethod eInputMethod);
TRUSS_C_API vr::EVROverlayError tr_ovw_GetOverlayMouseScale(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle, vr::HmdVector2_t * pvecMouseScale);
TRUSS_C_API vr::EVROverlayError tr_ovw_SetOverlayMouseScale(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle, vr::HmdVector2_t * pvecMouseScale);
TRUSS_C_API bool tr_ovw_ComputeOverlayIntersection(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle, vr::VROverlayIntersectionParams_t * pParams, vr::VROverlayIntersectionResults_t * pResults);
TRUSS_C_API bool tr_ovw_IsHoverTargetOverlay(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle);
TRUSS_C_API vr::VROverlayHandle_t tr_ovw_GetGamepadFocusOverlay(vr::IVROverlay* self);
TRUSS_C_API vr::EVROverlayError tr_ovw_SetGamepadFocusOverlay(vr::IVROverlay* self, vr::VROverlayHandle_t ulNewFocusOverlay);
TRUSS_C_API vr::EVROverlayError tr_ovw_SetOverlayNeighbor(vr::IVROverlay* self, vr::EOverlayDirection eDirection, vr::VROverlayHandle_t ulFrom, vr::VROverlayHandle_t ulTo);
TRUSS_C_API vr::EVROverlayError tr_ovw_MoveGamepadFocusToNeighbor(vr::IVROverlay* self, vr::EOverlayDirection eDirection, vr::VROverlayHandle_t ulFrom);
TRUSS_C_API vr::EVROverlayError tr_ovw_SetOverlayDualAnalogTransform(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlay, vr::EDualAnalogWhich eWhich, vr::HmdVector2_t * pvCenter, float fRadius);
TRUSS_C_API vr::EVROverlayError tr_ovw_GetOverlayDualAnalogTransform(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlay, vr::EDualAnalogWhich eWhich, vr::HmdVector2_t * pvCenter, float * pfRadius);
TRUSS_C_API vr::EVROverlayError tr_ovw_SetOverlayTexture(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle, vr::Texture_t * pTexture);
TRUSS_C_API vr::EVROverlayError tr_ovw_ClearOverlayTexture(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle);
TRUSS_C_API vr::EVROverlayError tr_ovw_SetOverlayRaw(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle, void * pvBuffer, uint32_t unWidth, uint32_t unHeight, uint32_t unDepth);
TRUSS_C_API vr::EVROverlayError tr_ovw_SetOverlayFromFile(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle, const char * pchFilePath);
TRUSS_C_API vr::EVROverlayError tr_ovw_GetOverlayTexture(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle, void ** pNativeTextureHandle, void * pNativeTextureRef, uint32_t * pWidth, uint32_t * pHeight, uint32_t * pNativeFormat, vr::ETextureType * pAPIType, vr::EColorSpace * pColorSpace, vr::VRTextureBounds_t * pTextureBounds);
TRUSS_C_API vr::EVROverlayError tr_ovw_ReleaseNativeOverlayHandle(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle, void * pNativeTextureHandle);
TRUSS_C_API vr::EVROverlayError tr_ovw_GetOverlayTextureSize(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle, uint32_t * pWidth, uint32_t * pHeight);
TRUSS_C_API vr::EVROverlayError tr_ovw_CreateDashboardOverlay(vr::IVROverlay* self, const char * pchOverlayKey, const char * pchOverlayFriendlyName, vr::VROverlayHandle_t * pMainHandle, vr::VROverlayHandle_t * pThumbnailHandle);
TRUSS_C_API bool tr_ovw_IsDashboardVisible(vr::IVROverlay* self);
TRUSS_C_API bool tr_ovw_IsActiveDashboardOverlay(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle);
TRUSS_C_API vr::EVROverlayError tr_ovw_SetDashboardOverlaySceneProcess(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle, uint32_t unProcessId);
TRUSS_C_API vr::EVROverlayError tr_ovw_GetDashboardOverlaySceneProcess(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle, uint32_t * punProcessId);
TRUSS_C_API void tr_ovw_ShowDashboard(vr::IVROverlay* self, const char * pchOverlayToShow);
TRUSS_C_API vr::TrackedDeviceIndex_t tr_ovw_GetPrimaryDashboardDevice(vr::IVROverlay* self);
TRUSS_C_API vr::EVROverlayError tr_ovw_ShowKeyboard(vr::IVROverlay* self, vr::EGamepadTextInputMode eInputMode, vr::EGamepadTextInputLineMode eLineInputMode, const char * pchDescription, uint32_t unCharMax, const char * pchExistingText, bool bUseMinimalMode, uint64_t uUserValue);
TRUSS_C_API vr::EVROverlayError tr_ovw_ShowKeyboardForOverlay(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle, vr::EGamepadTextInputMode eInputMode, vr::EGamepadTextInputLineMode eLineInputMode, const char * pchDescription, uint32_t unCharMax, const char * pchExistingText, bool bUseMinimalMode, uint64_t uUserValue);
TRUSS_C_API uint32_t tr_ovw_GetKeyboardText(vr::IVROverlay* self, char * pchText, uint32_t cchText);
TRUSS_C_API void tr_ovw_HideKeyboard(vr::IVROverlay* self);
TRUSS_C_API void tr_ovw_SetKeyboardTransformAbsolute(vr::IVROverlay* self, vr::ETrackingUniverseOrigin eTrackingOrigin, vr::HmdMatrix34_t * pmatTrackingOriginToKeyboardTransform);
TRUSS_C_API void tr_ovw_SetKeyboardPositionForOverlay(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle, vr::HmdRect2_t avoidRect);
TRUSS_C_API vr::EVROverlayError tr_ovw_SetOverlayIntersectionMask(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle, vr::VROverlayIntersectionMaskPrimitive_t * pMaskPrimitives, uint32_t unNumMaskPrimitives, uint32_t unPrimitiveSize);
TRUSS_C_API vr::EVROverlayError tr_ovw_GetOverlayFlags(vr::IVROverlay* self, vr::VROverlayHandle_t ulOverlayHandle, uint32_t * pFlags);
TRUSS_C_API vr::VRMessageOverlayResponse tr_ovw_ShowMessageOverlay(vr::IVROverlay* self, const char * pchText, const char * pchCaption, const char * pchButton0Text, const char * pchButton1Text, const char * pchButton2Text, const char * pchButton3Text);
TRUSS_C_API void tr_ovw_CloseMessageOverlay(vr::IVROverlay* self);
TRUSS_C_API vr::EVRRenderModelError tr_ovw_LoadRenderModel_Async(vr::IVRRenderModels* self, const char * pchRenderModelName, vr::RenderModel_t ** ppRenderModel);
TRUSS_C_API void tr_ovw_FreeRenderModel(vr::IVRRenderModels* self, vr::RenderModel_t * pRenderModel);
TRUSS_C_API vr::EVRRenderModelError tr_ovw_LoadTexture_Async(vr::IVRRenderModels* self, vr::TextureID_t textureId, vr::RenderModel_TextureMap_t ** ppTexture);
TRUSS_C_API void tr_ovw_FreeTexture(vr::IVRRenderModels* self, vr::RenderModel_TextureMap_t * pTexture);
TRUSS_C_API vr::EVRRenderModelError tr_ovw_LoadTextureD3D11_Async(vr::IVRRenderModels* self, vr::TextureID_t textureId, void * pD3D11Device, void ** ppD3D11Texture2D);
TRUSS_C_API vr::EVRRenderModelError tr_ovw_LoadIntoTextureD3D11_Async(vr::IVRRenderModels* self, vr::TextureID_t textureId, void * pDstTexture);
TRUSS_C_API void tr_ovw_FreeTextureD3D11(vr::IVRRenderModels* self, void * pD3D11Texture2D);
TRUSS_C_API uint32_t tr_ovw_GetRenderModelName(vr::IVRRenderModels* self, uint32_t unRenderModelIndex, char * pchRenderModelName, uint32_t unRenderModelNameLen);
TRUSS_C_API uint32_t tr_ovw_GetRenderModelCount(vr::IVRRenderModels* self);
TRUSS_C_API uint32_t tr_ovw_GetComponentCount(vr::IVRRenderModels* self, const char * pchRenderModelName);
TRUSS_C_API uint32_t tr_ovw_GetComponentName(vr::IVRRenderModels* self, const char * pchRenderModelName, uint32_t unComponentIndex, char * pchComponentName, uint32_t unComponentNameLen);
TRUSS_C_API uint64_t tr_ovw_GetComponentButtonMask(vr::IVRRenderModels* self, const char * pchRenderModelName, const char * pchComponentName);
TRUSS_C_API uint32_t tr_ovw_GetComponentRenderModelName(vr::IVRRenderModels* self, const char * pchRenderModelName, const char * pchComponentName, char * pchComponentRenderModelName, uint32_t unComponentRenderModelNameLen);
TRUSS_C_API bool tr_ovw_GetComponentStateForDevicePath(vr::IVRRenderModels* self, const char * pchRenderModelName, const char * pchComponentName, vr::VRInputValueHandle_t devicePath, vr::RenderModel_ControllerMode_State_t * pState, vr::RenderModel_ComponentState_t * pComponentState);
TRUSS_C_API bool tr_ovw_GetComponentState(vr::IVRRenderModels* self, const char * pchRenderModelName, const char * pchComponentName, vr::VRControllerState_t * pControllerState, vr::RenderModel_ControllerMode_State_t * pState, vr::RenderModel_ComponentState_t * pComponentState);
TRUSS_C_API bool tr_ovw_RenderModelHasComponent(vr::IVRRenderModels* self, const char * pchRenderModelName, const char * pchComponentName);
TRUSS_C_API uint32_t tr_ovw_GetRenderModelThumbnailURL(vr::IVRRenderModels* self, const char * pchRenderModelName, char * pchThumbnailURL, uint32_t unThumbnailURLLen, vr::EVRRenderModelError * peError);
TRUSS_C_API uint32_t tr_ovw_GetRenderModelOriginalPath(vr::IVRRenderModels* self, const char * pchRenderModelName, char * pchOriginalPath, uint32_t unOriginalPathLen, vr::EVRRenderModelError * peError);
TRUSS_C_API const char * tr_ovw_GetRenderModelErrorNameFromEnum(vr::IVRRenderModels* self, vr::EVRRenderModelError error);
TRUSS_C_API vr::EVRNotificationError tr_ovw_CreateNotification(vr::IVRNotifications* self, vr::VROverlayHandle_t ulOverlayHandle, uint64_t ulUserValue, vr::EVRNotificationType type, const char * pchText, vr::EVRNotificationStyle style, vr::NotificationBitmap_t * pImage, vr::VRNotificationId * pNotificationId);
TRUSS_C_API vr::EVRNotificationError tr_ovw_RemoveNotification(vr::IVRNotifications* self, vr::VRNotificationId notificationId);
TRUSS_C_API const char * tr_ovw_GetSettingsErrorNameFromEnum(vr::IVRSettings* self, vr::EVRSettingsError eError);
TRUSS_C_API bool tr_ovw_Sync(vr::IVRSettings* self, bool bForce, vr::EVRSettingsError * peError);
TRUSS_C_API void tr_ovw_SetBool(vr::IVRSettings* self, const char * pchSection, const char * pchSettingsKey, bool bValue, vr::EVRSettingsError * peError);
TRUSS_C_API void tr_ovw_SetInt32(vr::IVRSettings* self, const char * pchSection, const char * pchSettingsKey, int32_t nValue, vr::EVRSettingsError * peError);
TRUSS_C_API void tr_ovw_SetFloat(vr::IVRSettings* self, const char * pchSection, const char * pchSettingsKey, float flValue, vr::EVRSettingsError * peError);
TRUSS_C_API void tr_ovw_SetString(vr::IVRSettings* self, const char * pchSection, const char * pchSettingsKey, const char * pchValue, vr::EVRSettingsError * peError);
TRUSS_C_API bool tr_ovw_GetBool(vr::IVRSettings* self, const char * pchSection, const char * pchSettingsKey, vr::EVRSettingsError * peError);
TRUSS_C_API int32_t tr_ovw_GetInt32(vr::IVRSettings* self, const char * pchSection, const char * pchSettingsKey, vr::EVRSettingsError * peError);
TRUSS_C_API float tr_ovw_GetFloat(vr::IVRSettings* self, const char * pchSection, const char * pchSettingsKey, vr::EVRSettingsError * peError);
TRUSS_C_API void tr_ovw_GetString(vr::IVRSettings* self, const char * pchSection, const char * pchSettingsKey, char * pchValue, uint32_t unValueLen, vr::EVRSettingsError * peError);
TRUSS_C_API void tr_ovw_RemoveSection(vr::IVRSettings* self, const char * pchSection, vr::EVRSettingsError * peError);
TRUSS_C_API void tr_ovw_RemoveKeyInSection(vr::IVRSettings* self, const char * pchSection, const char * pchSettingsKey, vr::EVRSettingsError * peError);
TRUSS_C_API vr::EVRScreenshotError tr_ovw_RequestScreenshot(vr::IVRScreenshots* self, vr::ScreenshotHandle_t * pOutScreenshotHandle, vr::EVRScreenshotType type, const char * pchPreviewFilename, const char * pchVRFilename);
TRUSS_C_API vr::EVRScreenshotError tr_ovw_HookScreenshot(vr::IVRScreenshots* self, vr::EVRScreenshotType * pSupportedTypes, int numTypes);
TRUSS_C_API vr::EVRScreenshotType tr_ovw_GetScreenshotPropertyType(vr::IVRScreenshots* self, vr::ScreenshotHandle_t screenshotHandle, vr::EVRScreenshotError * pError);
TRUSS_C_API uint32_t tr_ovw_GetScreenshotPropertyFilename(vr::IVRScreenshots* self, vr::ScreenshotHandle_t screenshotHandle, vr::EVRScreenshotPropertyFilenames filenameType, char * pchFilename, uint32_t cchFilename, vr::EVRScreenshotError * pError);
TRUSS_C_API vr::EVRScreenshotError tr_ovw_UpdateScreenshotProgress(vr::IVRScreenshots* self, vr::ScreenshotHandle_t screenshotHandle, float flProgress);
TRUSS_C_API vr::EVRScreenshotError tr_ovw_TakeStereoScreenshot(vr::IVRScreenshots* self, vr::ScreenshotHandle_t * pOutScreenshotHandle, const char * pchPreviewFilename, const char * pchVRFilename);
TRUSS_C_API vr::EVRScreenshotError tr_ovw_SubmitScreenshot(vr::IVRScreenshots* self, vr::ScreenshotHandle_t screenshotHandle, vr::EVRScreenshotType type, const char * pchSourcePreviewFilename, const char * pchSourceVRFilename);
TRUSS_C_API uint32_t tr_ovw_LoadSharedResource(vr::IVRResources* self, const char * pchResourceName, char * pchBuffer, uint32_t unBufferLen);
TRUSS_C_API uint32_t tr_ovw_GetResourceFullPath(vr::IVRResources* self, const char * pchResourceName, const char * pchResourceTypeDirectory, char * pchPathBuffer, uint32_t unBufferLen);
TRUSS_C_API uint32_t tr_ovw_GetDriverCount(vr::IVRDriverManager* self);
TRUSS_C_API uint32_t tr_ovw_GetDriverName(vr::IVRDriverManager* self, vr::DriverId_t nDriver, char * pchValue, uint32_t unBufferSize);
TRUSS_C_API DriverHandle_t tr_ovw_GetDriverHandle(vr::IVRDriverManager* self, const char * pchDriverName);
TRUSS_C_API vr::EVRInputError tr_ovw_SetActionManifestPath(vr::IVRInput* self, const char * pchActionManifestPath);
TRUSS_C_API vr::EVRInputError tr_ovw_GetActionSetHandle(vr::IVRInput* self, const char * pchActionSetName, vr::VRActionSetHandle_t * pHandle);
TRUSS_C_API vr::EVRInputError tr_ovw_GetActionHandle(vr::IVRInput* self, const char * pchActionName, vr::VRActionHandle_t * pHandle);
TRUSS_C_API vr::EVRInputError tr_ovw_GetInputSourceHandle(vr::IVRInput* self, const char * pchInputSourcePath, vr::VRInputValueHandle_t * pHandle);
TRUSS_C_API vr::EVRInputError tr_ovw_UpdateActionState(vr::IVRInput* self, vr::VRActiveActionSet_t * pSets, uint32_t unSizeOfVRSelectedActionSet_t, uint32_t unSetCount);
TRUSS_C_API vr::EVRInputError tr_ovw_GetDigitalActionData(vr::IVRInput* self, vr::VRActionHandle_t action, vr::InputDigitalActionData_t * pActionData, uint32_t unActionDataSize, vr::VRInputValueHandle_t ulRestrictToDevice);
TRUSS_C_API vr::EVRInputError tr_ovw_GetAnalogActionData(vr::IVRInput* self, vr::VRActionHandle_t action, vr::InputAnalogActionData_t * pActionData, uint32_t unActionDataSize, vr::VRInputValueHandle_t ulRestrictToDevice);
TRUSS_C_API vr::EVRInputError tr_ovw_GetPoseActionData(vr::IVRInput* self, vr::VRActionHandle_t action, vr::ETrackingUniverseOrigin eOrigin, float fPredictedSecondsFromNow, vr::InputPoseActionData_t * pActionData, uint32_t unActionDataSize, vr::VRInputValueHandle_t ulRestrictToDevice);
TRUSS_C_API vr::EVRInputError tr_ovw_GetSkeletalActionData(vr::IVRInput* self, vr::VRActionHandle_t action, vr::InputSkeletalActionData_t * pActionData, uint32_t unActionDataSize);
TRUSS_C_API vr::EVRInputError tr_ovw_GetBoneCount(vr::IVRInput* self, vr::VRActionHandle_t action, uint32_t * pBoneCount);
TRUSS_C_API vr::EVRInputError tr_ovw_GetBoneHierarchy(vr::IVRInput* self, vr::VRActionHandle_t action, vr::BoneIndex_t * pParentIndices, uint32_t unIndexArayCount);
TRUSS_C_API vr::EVRInputError tr_ovw_GetBoneName(vr::IVRInput* self, vr::VRActionHandle_t action, vr::BoneIndex_t nBoneIndex, char * pchBoneName, uint32_t unNameBufferSize);
TRUSS_C_API vr::EVRInputError tr_ovw_GetSkeletalReferenceTransforms(vr::IVRInput* self, vr::VRActionHandle_t action, vr::EVRSkeletalTransformSpace eTransformSpace, vr::EVRSkeletalReferencePose eReferencePose, vr::VRBoneTransform_t * pTransformArray, uint32_t unTransformArrayCount);
TRUSS_C_API vr::EVRInputError tr_ovw_GetSkeletalTrackingLevel(vr::IVRInput* self, vr::VRActionHandle_t action, vr::EVRSkeletalTrackingLevel * pSkeletalTrackingLevel);
TRUSS_C_API vr::EVRInputError tr_ovw_GetSkeletalBoneData(vr::IVRInput* self, vr::VRActionHandle_t action, vr::EVRSkeletalTransformSpace eTransformSpace, vr::EVRSkeletalMotionRange eMotionRange, vr::VRBoneTransform_t * pTransformArray, uint32_t unTransformArrayCount);
TRUSS_C_API vr::EVRInputError tr_ovw_GetSkeletalSummaryData(vr::IVRInput* self, vr::VRActionHandle_t action, vr::VRSkeletalSummaryData_t * pSkeletalSummaryData);
TRUSS_C_API vr::EVRInputError tr_ovw_GetSkeletalBoneDataCompressed(vr::IVRInput* self, vr::VRActionHandle_t action, vr::EVRSkeletalMotionRange eMotionRange, void * pvCompressedData, uint32_t unCompressedSize, uint32_t * punRequiredCompressedSize);
TRUSS_C_API vr::EVRInputError tr_ovw_DecompressSkeletalBoneData(vr::IVRInput* self, void * pvCompressedBuffer, uint32_t unCompressedBufferSize, vr::EVRSkeletalTransformSpace eTransformSpace, vr::VRBoneTransform_t * pTransformArray, uint32_t unTransformArrayCount);
TRUSS_C_API vr::EVRInputError tr_ovw_TriggerHapticVibrationAction(vr::IVRInput* self, vr::VRActionHandle_t action, float fStartSecondsFromNow, float fDurationSeconds, float fFrequency, float fAmplitude, vr::VRInputValueHandle_t ulRestrictToDevice);
TRUSS_C_API vr::EVRInputError tr_ovw_GetActionOrigins(vr::IVRInput* self, vr::VRActionSetHandle_t actionSetHandle, vr::VRActionHandle_t digitalActionHandle, vr::VRInputValueHandle_t * originsOut, uint32_t originOutCount);
TRUSS_C_API vr::EVRInputError tr_ovw_GetOriginLocalizedName(vr::IVRInput* self, vr::VRInputValueHandle_t origin, char * pchNameArray, uint32_t unNameArraySize, int32_t unStringSectionsToInclude);
TRUSS_C_API vr::EVRInputError tr_ovw_GetOriginTrackedDeviceInfo(vr::IVRInput* self, vr::VRInputValueHandle_t origin, vr::InputOriginInfo_t * pOriginInfo, uint32_t unOriginInfoSize);
TRUSS_C_API vr::EVRInputError tr_ovw_ShowActionOrigins(vr::IVRInput* self, vr::VRActionSetHandle_t actionSetHandle, vr::VRActionHandle_t ulActionHandle);
TRUSS_C_API vr::EVRInputError tr_ovw_ShowBindingsForActionSet(vr::IVRInput* self, vr::VRActiveActionSet_t * pSets, uint32_t unSizeOfVRSelectedActionSet_t, uint32_t unSetCount, vr::VRInputValueHandle_t originToHighlight);
TRUSS_C_API vr::EIOBufferError tr_ovw_Open(vr::IVRIOBuffer* self, const char * pchPath, vr::EIOBufferMode mode, uint32_t unElementSize, uint32_t unElements, vr::IOBufferHandle_t * pulBuffer);
TRUSS_C_API vr::EIOBufferError tr_ovw_Close(vr::IVRIOBuffer* self, vr::IOBufferHandle_t ulBuffer);
TRUSS_C_API vr::EIOBufferError tr_ovw_Read(vr::IVRIOBuffer* self, vr::IOBufferHandle_t ulBuffer, void * pDst, uint32_t unBytes, uint32_t * punRead);
TRUSS_C_API vr::EIOBufferError tr_ovw_Write(vr::IVRIOBuffer* self, vr::IOBufferHandle_t ulBuffer, void * pSrc, uint32_t unBytes);
TRUSS_C_API vr::PropertyContainerHandle_t tr_ovw_PropertyContainer(vr::IVRIOBuffer* self, vr::IOBufferHandle_t ulBuffer);
TRUSS_C_API bool tr_ovw_HasReaders(vr::IVRIOBuffer* self, vr::IOBufferHandle_t ulBuffer);
TRUSS_C_API vr::EVRSpatialAnchorError tr_ovw_CreateSpatialAnchorFromDescriptor(vr::IVRSpatialAnchors* self, const char * pchDescriptor, vr::SpatialAnchorHandle_t * pHandleOut);
TRUSS_C_API vr::EVRSpatialAnchorError tr_ovw_CreateSpatialAnchorFromPose(vr::IVRSpatialAnchors* self, vr::TrackedDeviceIndex_t unDeviceIndex, vr::ETrackingUniverseOrigin eOrigin, vr::SpatialAnchorPose_t * pPose, vr::SpatialAnchorHandle_t * pHandleOut);
TRUSS_C_API vr::EVRSpatialAnchorError tr_ovw_GetSpatialAnchorPose(vr::IVRSpatialAnchors* self, vr::SpatialAnchorHandle_t unHandle, vr::ETrackingUniverseOrigin eOrigin, vr::SpatialAnchorPose_t * pPoseOut);
TRUSS_C_API vr::EVRSpatialAnchorError tr_ovw_GetSpatialAnchorDescriptor(vr::IVRSpatialAnchors* self, vr::SpatialAnchorHandle_t unHandle, char * pchDescriptorOut, uint32_t * punDescriptorBufferLenInOut);

#endif
